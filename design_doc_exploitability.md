# Design Document: Calcul d'Exploitabilité pour Solver GTO

## Contexte et Objectif

L'exploitabilité est une métrique cruciale pour évaluer la qualité d'une stratégie GTO (Game Theory Optimal). Une stratégie parfaitement GTO a une exploitabilité de zéro, ce qui signifie qu'aucun adversaire ne peut obtenir un avantage contre elle. L'objectif de ce design doc est de proposer une implémentation du calcul d'exploitabilité pour le Solver GTO, en particulier pour les scénarios Heads-Up (HU) et 4-bet pot.

## Définition de l'Exploitabilité

L'exploitabilité d'une stratégie est définie comme le gain maximal qu'un adversaire parfait (best-response) peut obtenir contre cette stratégie. Mathématiquement, si σ est notre stratégie et BR(σ) est la meilleure réponse contre σ, alors:

Exploitabilité(σ) = u(BR(σ), σ) - u(σ, σ)

où u(a, b) est l'utilité espérée de la stratégie a contre la stratégie b.

## Architecture Proposée

### 1. Classe `ExploitabilityCalculator`

```cpp
class ExploitabilityCalculator {
public:
    ExploitabilityCalculator(const CFREngine& cfr_engine);
    
    // Calcule l'exploitabilité de la stratégie actuelle
    double compute_exploitability();
    
    // Calcule l'exploitabilité pour un scénario spécifique (HU ou 4-bet pot)
    double compute_exploitability_for_scenario(const GameScenario& scenario);
    
private:
    const CFREngine& cfr_engine_;
    
    // Calcule la meilleure réponse contre la stratégie actuelle
    std::map<std::string, StrategyInfo> compute_best_response(int player_index);
    
    // Calcule l'utilité espérée d'une stratégie contre une autre
    double compute_expected_utility(const std::map<std::string, StrategyInfo>& strategy_a, 
                                   const std::map<std::string, StrategyInfo>& strategy_b);
};
```

### 2. Classe `GameScenario`

```cpp
class GameScenario {
public:
    // Constructeur pour un scénario Heads-Up
    static GameScenario create_heads_up_scenario(int initial_stack = 100, int ante_size = 0);
    
    // Constructeur pour un scénario 4-bet pot
    static GameScenario create_four_bet_pot_scenario(int initial_stack = 100, int ante_size = 0);
    
    // Getters
    GameState get_initial_state() const;
    std::string get_history() const;
    
private:
    GameState initial_state_;
    std::string history_;
};
```

### 3. Algorithme de Best-Response

L'algorithme de best-response est un élément clé du calcul d'exploitabilité. Il calcule la stratégie optimale contre une stratégie fixe.

```cpp
std::map<std::string, StrategyInfo> ExploitabilityCalculator::compute_best_response(int player_index) {
    std::map<std::string, StrategyInfo> best_response;
    
    // Pour chaque InfoSet du joueur player_index
    for (const auto& infoset_key : cfr_engine_.get_infosets_for_player(player_index)) {
        // Obtenir les actions possibles et leurs probabilités dans la stratégie actuelle
        StrategyInfo current_strategy = cfr_engine_.get_strategy_info(infoset_key);
        
        // Calculer l'utilité espérée de chaque action
        std::vector<double> action_utilities;
        for (const auto& action : current_strategy.actions) {
            // Calculer l'utilité espérée de cette action
            double utility = compute_action_utility(infoset_key, action);
            action_utilities.push_back(utility);
        }
        
        // Trouver l'action avec l'utilité maximale
        int best_action_index = std::distance(action_utilities.begin(), 
                                             std::max_element(action_utilities.begin(), action_utilities.end()));
        
        // Créer une stratégie best-response qui joue toujours l'action optimale
        StrategyInfo best_response_strategy;
        best_response_strategy.actions = current_strategy.actions;
        best_response_strategy.strategy = std::vector<double>(current_strategy.actions.size(), 0.0);
        best_response_strategy.strategy[best_action_index] = 1.0;
        best_response_strategy.found = true;
        
        best_response[infoset_key] = best_response_strategy;
    }
    
    return best_response;
}
```

## Implémentation

### Phase 1: Implémentation de Base

1. Créer les classes `ExploitabilityCalculator` et `GameScenario`.
2. Implémenter l'algorithme de best-response.
3. Implémenter le calcul d'exploitabilité pour le scénario Heads-Up.

### Phase 2: Extension et Optimisation

1. Implémenter le calcul d'exploitabilité pour le scénario 4-bet pot.
2. Optimiser l'algorithme de best-response pour améliorer les performances.
3. Ajouter des fonctionnalités de visualisation pour suivre la convergence de l'exploitabilité au fil des itérations.

### Phase 3: Tests et Validation

1. Créer des tests unitaires pour valider l'implémentation.
2. Valider l'implémentation sur des jeux simples comme le Kuhn Poker, où l'exploitabilité optimale est connue.
3. Comparer les résultats avec d'autres solvers GTO pour valider la précision.

## Intégration avec le Solver Existant

L'`ExploitabilityCalculator` sera intégré au solver existant comme suit:

```cpp
// Dans main.cpp
void compute_and_display_exploitability(const CFREngine& cfr_engine) {
    ExploitabilityCalculator calculator(cfr_engine);
    
    // Calculer l'exploitabilité pour le scénario Heads-Up
    GameScenario hu_scenario = GameScenario::create_heads_up_scenario();
    double hu_exploitability = calculator.compute_exploitability_for_scenario(hu_scenario);
    spdlog::info("Exploitabilité HU: {}", hu_exploitability);
    
    // Calculer l'exploitabilité pour le scénario 4-bet pot
    GameScenario four_bet_scenario = GameScenario::create_four_bet_pot_scenario();
    double four_bet_exploitability = calculator.compute_exploitability_for_scenario(four_bet_scenario);
    spdlog::info("Exploitabilité 4-bet pot: {}", four_bet_exploitability);
}
```

## Considérations de Performance

Le calcul d'exploitabilité peut être coûteux en termes de calcul, surtout pour des jeux complexes comme le No-Limit Hold'em. Pour améliorer les performances:

1. Utiliser la parallélisation pour calculer la best-response pour différents InfoSets en parallèle.
2. Mettre en cache les résultats intermédiaires pour éviter les calculs redondants.
3. Utiliser des techniques d'approximation pour les jeux très grands, comme l'échantillonnage Monte Carlo.

## Validation et Métriques

Pour valider l'implémentation:

1. Vérifier que l'exploitabilité diminue au fil des itérations de l'algorithme CFR.
2. Vérifier que l'exploitabilité atteint des valeurs proches de zéro pour des jeux simples comme le Kuhn Poker après un nombre suffisant d'itérations.
3. Comparer les résultats avec d'autres solvers GTO pour valider la précision.

## Conclusion

L'implémentation du calcul d'exploitabilité permettra de mesurer la qualité des stratégies générées par le solver GTO et de suivre sa convergence vers une stratégie optimale. Cette fonctionnalité est essentielle pour valider les performances du solver et pour identifier les domaines d'amélioration potentiels.
